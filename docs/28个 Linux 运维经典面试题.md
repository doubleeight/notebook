<div><div class="pgc-img"><img src="http://p3.pstatp.com/large/pgc-image/57039add64334cd0884e8fb47b09f187" img_width="449" img_height="250" alt="干货 | 28个 Linux 运维经典面试题" inline="0"><p class="pgc-img-caption"></p></div><p class="ql-align-justify">今天给大家分享一些关于Linux运维的经典面试题，如果有小伙伴需要Linux资源可以在评论下方回复<strong>“Linux”</strong>获取哦！</p><p><strong>1、Linux如何挂载windows下的共享目录？</strong></p><p>mount.cifs <em>//IP地址/server /mnt/server -o user=administrator,password=123456</em></p><p>linux 下的server需要自己手动建一个 后面的user与pass 是windows主机的账号和密码 注意空格 和逗号</p><p><strong>2、如何查看http的并发请求数与其TCP连接状态？</strong></p><p>netstat -n | awk ‘/^tcp/ {++b[$NF]}’ END {for(a in b) print a,b[a]}’</p><p>还有ulimit -n 查看linux系统打开最大的文件描述符，这里默认1024，不修改这里web服务器修改再大也没用。若要用就修改很几个办法，这里说其中一个：</p><p>修改/etc/security/limits.conf</p><p>* soft nofile 10240</p><p>* hard nofile 10240</p><p>重启后生效</p><p><strong>3、如何用tcpdump嗅探80端口的访问看看谁最高？</strong></p><p>tcpdump -i eth0 -tnn dst port 80 -c 1000 | awk -F”.” ‘{print $1″.”$2″.”$3″.”$4″.”}’ | sort |uniq -c | sort -nr | head-5</p><p><strong>4、如何查看/var/log目录下的文件数？</strong></p><p>ls /var/log/ -1R | grep “-” | wc -l</p><p><strong>5、如何查看Linux系统每个ip的连接数？</strong></p><p>netstat -n | awk ‘/^tcp/ {print $5}’ | awk -F: ‘{print $1}’ | sort | uniq -c | sort -rn</p><p><strong>6、shell下生成32位随机密码？</strong></p><p>cat /dev/urandom | head -1 | md5sum | head -c 32 &gt;&gt; /pass</p><p><strong>7、统计出apache的access.log中访问量最多的5个ip？</strong></p><p>cat access.log | awk ‘{print $1}’ | sort | uniq -c | sort -n -r | head -5</p><p><strong>8、如何查看二进制文件的内容？</strong></p><p>我们一般通过hexdump命令 来查看二进制文件的内容。</p><p>hexdump -C XXX(文件名) -C是参数 不同的参数有不同的意义</p><p>-C 是比较规范的 十六进制和ASCII码显示</p><p>-c 是单字节字符显示</p><p>-b 单字节八进制显示</p><p>-o 是双字节八进制显示</p><p>-d 是双字节十进制显示</p><p>-x 是双字节十六进制显示</p><p><strong>9、ps aux 中的VSZ代表什么意思，RSS代表什么意思？</strong></p><p class="ql-align-justify"><strong>VSZ：</strong>虚拟内存集，进程占用的虚拟内存空间。</p><p class="ql-align-justify"><strong>RSS：</strong>物理内存集，进程战用实际物理内存空间。</p><p><strong>10、如何检测并修复/dev/hda5？</strong></p><p>fsck用来检查和维护不一致的文件系统。若系统掉电或磁盘发生问题，可利用fsck命令对文件系统进行检查。</p><p><strong>11、介绍下Linux系统的开机启动顺序？</strong></p><p>加载BIOS–&gt;读取MBR–&gt;Boot Loader–&gt;加载内核–&gt;用户层init一句inittab文件来设定系统运行的等级(一般3或者5，3是多用户命令行，5是界面)–&gt;init进程执行rc.syninit–&gt;启动内核模块–&gt;执行不同级别运行的脚本程序–&gt;执行/etc/rc.d/rc.local(本地运行服务)–&gt;执行/bin/login，就可以登录了。</p><p><strong>12、符号链接与硬</strong><strong>链接的</strong><strong>区别？</strong></p><p class="ql-align-justify">我们可以把符号链接，也就是软连接，当做是 Windows系统里的快捷方式。</p><p class="ql-align-justify">硬链接 就好像是 又复制了一份，举例说明：</p><p class="ql-align-justify">ln 3.txt 4.txt 这是硬链接，相当于复制，不可以跨分区，但修改3，4会跟着变，若删除3，4不受任何影响。</p><p class="ql-align-justify">ln -s 3.txt 4.txt 这是软连接，相当于快捷方式。修改4，3也会跟着变，若删除3，4就坏掉了，不可以用了。</p><p><strong>13、保存当前磁盘分区的分区表？</strong></p><p>dd if=/dev/sda of=./mbr.txt bs=1 count=512</p><p><strong>14、如何在文本里面进行复制、粘贴，删除行，删除全部，按行查找和按字母查找？</strong></p><p class="ql-align-justify"><br></p><p class="ql-align-justify">以下操作全部在命令行状态操作，不要在编辑状态操作。</p><p class="ql-align-justify">在文本里移动到想要复制的行 按 yy 想复制到哪就移动到哪，然后按 P 就粘贴了。</p><p class="ql-align-justify">删除行 移动到改行 按dd。</p><p class="ql-align-justify">删除全部 dG 这里注意G一定要大写。</p><p class="ql-align-justify">按行查找：90 这样就是找到第90行。</p><p class="ql-align-justify">按字母查找 /path 这样就是 找到path这个单词所在的位置，文本里可能存在多个,多次查找会显示在不同的位置。</p><p><strong>15、手动安装grub？</strong></p><p>grub-install /dev/sda</p><p><strong>16、修改内核参数？</strong></p><p>vi /etc/sysctl.conf 这里修改参数</p><p>sysctl -p 刷新后可用</p><p><strong>17、在1-39内取随机数？</strong></p><p>expr $[RANDOM%39] +1</p><p class="ql-align-justify">RANDOM随机数</p><p class="ql-align-justify">%39取余数范围0-38</p><p><strong>18、限制apache每秒新建连接数为1，峰值为3？</strong></p><p class="ql-align-justify">每秒新建连接数一般都是由防火墙来做，apache本身好像无法设置每秒新建连接数，只能设置最大连接：</p><p>iptables -A INPUT -d 172.16.100.1 -p tcp –dport 80 -m limit –limit 1/second -j ACCEPT</p><p><strong>19、FTP的主动模式和被动模式</strong></p><p class="ql-align-justify">FTP协议有两种工作方式：PORT方式和PASV方式，中文意思为主动式和被动式。</p><p class="ql-align-justify">PORT（主动）方式的连接过程是：客户端向服务器的FTP端口（默认是21）发送连接请求，服务器接受连接，建立一条命令链路。当需要传送数据时，客户端在命令链路上用 PORT 命令告诉服务器：“我打开了XX端口，你过来连接我”。于是服务器从20端口向客户端的 XX 端口发送连接请求，建立一条数据链路来传送数据。</p><p class="ql-align-justify">PASV（被动）方式的连接过程是：客户端向服务器的FTP端口（默认是21）发送连接请求，服务器接受连接，建立一条命令链路。当需要传送数据时，服务器在命令链路上用 PASV 命令告诉客户端：“我打开了XX端口，你过来连接我”。于是客户端向服务器的 XX 端口发送连接请求，建立一条数据链路来传送数据。</p><p class="ql-align-justify">从上面可以看出，两种方式的命令链路连接方法是一样的，而数据链路的建立方法就完全不同。</p><p><strong>20、显示/etc/inittab中以#开头，且后面跟了一个或者多个空白字符，而后又跟了任意非空白字符的行？</strong></p><p>grep “^<em>#{1,}[^]” /etc/inittab</em></p><p><strong>21、显示/etc/inittab中包含了：一个数字：(即两个冒号中间一个数字)的行？</strong></p><p>grep “:[0-9]{1}:” /etc/inittab</p><p><strong>22、怎么把脚本添加到系统服务里，即用service来调用？</strong></p><p>在脚本里加入：</p><p>#!/bin/bash</p><p><em># chkconfig: 345 85 15</em></p><p><em># description: httpd</em></p><p>然后保存，chkconfig httpd –add 创建系统服务，现在就可以使用service 来 start or restart。</p><p><strong>23、写一个脚本，实现批量添加20个用户，用户名为user01-20，密码为user后面跟5个随机字符？</strong></p><p>#!/bin/bash</p><p><em>#description: useradd</em></p><p>for i in `seq -f”%02g” 1 20`;do</p><p>useradd user$i</p><p>echo “user$i-`echo $RANDOM|md5sum|cut -c 1-5`”|passwd –stdinuser$i &gt;/dev/null 2&gt;&amp;1</p><p>done</p><p><strong>24、写一个脚本，实现判断192.168.1.0/24网络里，当前在线的IP有哪些，能ping通则认为在线？</strong></p><p>#!/bin/bash</p><p>for ip in `seq 1 255`</p><p>do</p><p>ping -c 1 192.168.1.$ip &gt; /dev/null 2&gt;&amp;1</p><p>if [ $? -eq 0 ]; then</p><p>echo 192.168.1.$ip UP</p><p>else</p><p>echo 192.168.1.$ip DOWN</p><p>fi</p><p>}&amp;</p><p>done</p><p>wait</p><p><strong>25、写一个脚本，判断一个指定的脚本是否是语法错误；如果有错误，则提醒用户键入Q或者q无视错误并退出其它任何键可以通过vim打开这个指定的脚本？</strong></p><p>[root@localhost tmp]<em># cat checksh.sh</em></p><p>#!/bin/bash</p><p>read -p “please input check script-&gt; ” file</p><p>if [ -f $file ]; then</p><p>sh -n $file &gt; /dev/null 2&gt;&amp;1</p><p>if [ $? -ne 0 ]; then</p><p>read -p “You input $file syntax error,[Type q to exit or Type vim to edit]” answer</p><p>case $answer in</p><p>q | Q)</p><p>exit 0</p><p>;;</p><p>vim )</p><p>vim $file</p><p>;;</p><p>*）</p><p>exit 0</p><p>;;</p><p>esac</p><p>fi</p><p>else</p><p>echo “$file not exist”</p><p>exit 1</p><p>fi</p><p><strong>26、写一个脚本，要求如何？</strong></p><p class="ql-align-justify"><strong>创建一个函数，能接受两个参数：</strong></p><p class="ql-align-justify">1）第一个参数为URL，即可下载的文件；第二个参数为目录，即下载后保存的位置；</p><p class="ql-align-justify">2）如果用户给的目录不存在，则提示用户是否创建；如果创建就继续执行，否则，函数返回一个51的错误值给调用脚本；</p><p class="ql-align-justify">3）如果给的目录存在，则下载文件；下载命令执行结束后测试文件下载成功与否；如果成功，则返回0给调用脚本，否则，返回52给调用脚本。</p><div class="pgc-img"><img src="http://p1.pstatp.com/large/pgc-image/4cd8601e7d6e42e9a201e76ad58f17b0" img_width="669" img_height="514" alt="干货 | 28个 Linux 运维经典面试题" inline="0"><p class="pgc-img-caption"></p></div><p><strong>27、写一个脚本，详细需求如下？</strong></p><p class="ql-align-justify">1、创建一个函数，可以接受一个磁盘设备路径（如/dev/sdb）作为参数；在真正开始后面步骤之前提醒用户有危险，并让用户选择是否继续；而后将此磁盘设备上的所有分区清空（提示，使用命令dd if=/dev/zero of=/dev/sdb bs=512 count=1实现，注意其中的设备路径不要写错了；</p><p class="ql-align-justify">如果此步骤失败，返回67给主程序；</p><p class="ql-align-justify">接着在此磁盘设备上创建两个主分区，一个大小为100M，一个大小为1G；如果此步骤失败，返回68给主程序；</p><p class="ql-align-justify">格式化此两分区，文件系统类型为ext3；如果此步骤失败，返回69给主程序；</p><p class="ql-align-justify">如果上述过程都正常，返回0给主程序；</p><p class="ql-align-justify">2、调用此函数；并通过接收函数执行的返回值来判断其执行情况，并将信息显示出来。</p><p>local Darray=(`ls /dev/sd[a-z]`)</p><p>for i in ${Darray};do</p><p>[[ “$i” == “$1” ]] &amp;&amp; Sd=$i &amp;&amp;break</p><p>done</p><p>else</p><p>return66</p><p>fi</p><p><em>#当匹配成功，进入选择，告诉用户，是否继续，输错的话进入无限循环，当用户选择Y,则清空目标分区，且跳出while循环</em></p><p>while :;do</p><p>read -p “Warning!!!This operation will clean $Sd data.Next=y,Quit=n [y|n]:” Choice</p><p>case $Choice in</p><p>y)</p><p>dd if=/dev/zero of=$Sd bs=512 count=1 &amp;&gt; /dev/null &amp;&amp;break || return 67 ;;</p><p>n)</p><p>exit 88 ;;</p><p>*)</p><p>echo “Invalid choice,please choice again.” ;;</p><p>esac</p><p>done</p><p><em>#使用echo传递给fdisk进行分区，如果此命令失败，则跳转出去，错误值68，需要注意的是，有时候这个返回值很诡异，笔者之前成功与否都是返回的1，后来重启之后，就好了，如果慎重的话，可以对创建的分区，进行判断，不过就需要使用其他工具截取相关字段了，虽有些小麻烦，但无大碍</em></p><p>echo-e “np1+100Mnp2+1024Mw”|fdisk /dev/sdb&amp;&gt; /dev/null || || return 68</p><p><em>#格式化之前，让内核重新读取磁盘分区表，值得注意的是，有的系统版本，使用partprobe无效，譬如笔者的环境是rhel5.8，而rhel6.0以后，这个命令就很危险了，而使用partx -a /dev/sdb则效果更好…此项需慎重，如果格式化失败，则告知把失败的分区定义成变量，且跳出函数，并带出错误值69</em></p><p>`partprobe`</p><p>Part=`fdisk -l /dev/$Sd|tail -2|cut -d” ” -f1`</p><p>for M in ${Part};do</p><p>mke2fs -j $M &amp;&gt; /dev/null &amp;&amp; ErrorPart=$M &amp;&amp;return 69</p><p>done</p><p>return 0</p><p>}</p><p><em>#下面代码，调用函数，接收函数返回值，根据返回值进行判断哪里出错。</em></p><p>Disk_Mod $1</p><p>Res=$?</p><p>[ $Res-eq 0 ] &amp;&amp; exit 0</p><p>[ $Res-eq 66 ] &amp;&amp; echo “Error! Invalid input.”</p><p>[ $Res-eq 67 ] &amp;&amp; echo “Error! Command -&gt; dd fdisk mke2fs</p><p><strong>28、如何让history命令显示具体时间？</strong></p><p>HISTTIMEFORMAT=”%Y-%m-%d %H:%M:%S”</p><p>export HISTTIMEFORMAT</p><p>重新开机后会还原，可以写/etc/profil。</p></div>
